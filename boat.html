<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dreamlike River Journey</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #000511 0%, #001122 50%, #002244 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.85);
            font-size: 11px;
            z-index: 100;
            background: rgba(8, 14, 44, 0.15);
            padding: 18px 24px;
            border-radius: 24px;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(123, 162, 251, 0.15);
            box-shadow: 
                0 4px 24px -1px rgba(0, 11, 40, 0.25),
                inset 0 0 20px rgba(123, 162, 251, 0.05);
            font-weight: 300;
            letter-spacing: 0.8px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #controls:hover {
            background: rgba(13, 20, 58, 0.2);
            transform: translateY(-2px) scale(1.02);
            box-shadow: 
                0 8px 32px -2px rgba(0, 11, 40, 0.3),
                inset 0 0 20px rgba(123, 162, 251, 0.08);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.95);
            font-size: 18px;
            font-weight: 300;
            z-index: 200;
            text-shadow: 0 0 25px rgba(123, 162, 251, 0.8);
            opacity: 0;
            animation: fadeInOut 2.5s ease-in-out infinite;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
        }
        
        #atmosphere {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 0%, rgba(0, 50, 100, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: 50;
        }
        
        canvas {
            display: block;
            image-rendering: high-quality;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">âœ¨ Loading your dreamlike journey...</div>
        <div id="atmosphere"></div>
        <div id="controls">
            <div style="font-size: 12px; margin-bottom: 8px; color: #88CCFF;">ðŸŒ™ Nighttime River Journey</div>
            <div><strong>WASD</strong> â€¢ Navigate through waters</div>
            <div><strong>Mouse</strong> â€¢ Look around the mystical world</div>
            <div><strong>Space</strong> â€¢ Dash through moonlit waters</div>
            <div><strong>Shift</strong> â€¢ Peaceful gliding mode</div>
            <div style="margin-top: 8px; font-size: 10px; color: #AACCFF;">Click to capture mouse for better control</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, boat, stars, milkyWay;
        let clock = new THREE.Clock();
        let keys = {};
        let mouseX = 0, mouseY = 0;
        let boatSpeed = 0.025;
        
        // Track loading state
        let isLoading = true;
        let loadedItems = 0;
        const totalItems = 6; // Total number of major elements to load
        let dashMode = false;
        let glideMode = false;
        let riverSegments = [];
        let riverMaterial;
        let boatPosition = new THREE.Vector3(0, 0, 0);
        let boatRotation = new THREE.Euler(0, 0, 0);
        let cameraOffset = new THREE.Vector3(0, 2.5, 6);
        let rockingTime = 0;
        let mist = [];
        let fireflies = [];

        function init() {
            // Enhanced scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x001133, 0.008);

            // Camera with better field of view and initial position
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 3, 8); // Set initial camera position
            camera.lookAt(0, 0, 0);
            
            // Enhanced renderer with better quality
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000511, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            document.getElementById('container').appendChild(renderer.domElement);

            // Setup basic lighting first
            setupEnhancedLighting();
            
            // Initialize all major components and track loading
            Promise.all([
                new Promise(resolve => {
                    createEnhancedStarField();
                    loadedItems++;
                    resolve();
                }),
                new Promise(resolve => {
                    createEnhancedRiver();
                    loadedItems++;
                    resolve();
                }),
                new Promise(resolve => {
                    createDetailedBoat();
                    loadedItems++;
                    resolve();
                }),
                new Promise(resolve => {
                    createRichEnvironment();
                    loadedItems++;
                    resolve();
                }),
                new Promise(resolve => {
                    createMistEffects();
                    loadedItems++;
                    resolve();
                }),
                new Promise(resolve => {
                    createFireflies();
                    loadedItems++;
                    resolve();
                })
            ]).then(() => {
                setupEnhancedLighting();
                setupControls();
                isLoading = false;
                
                // Hide loading with fade effect
                document.getElementById('loading').style.opacity = '0';
                document.getElementById('loading').style.transition = 'opacity 1s ease';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            });
            
            animate();
        }

        function createEnhancedStarField() {
            // Create much more realistic and smaller stars
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 20000; // Increased star count
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                
                // Enhanced star distribution with more height and depth
                const radius = 1200 + Math.random() * 800; // Higher altitude
                const theta = Math.random() * Math.PI * 2;
                // Modified distribution to concentrate more stars higher in the sky
                const phi = Math.acos((Math.random() * 0.5 + 0.5) * Math.random() * 0.7);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.cos(phi) + 200; // Higher placement
                positions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
                
                // Realistic star colors and temperatures
                const temp = Math.random();
                const brightness = Math.random() * 0.8 + 0.2;
                
                if (temp < 0.2) {
                    // Blue giants (rare)
                    colors[i3] = 0.7 * brightness;
                    colors[i3 + 1] = 0.8 * brightness;
                    colors[i3 + 2] = 1.0 * brightness;
                } else if (temp < 0.4) {
                    // Blue-white stars
                    colors[i3] = 0.8 * brightness;
                    colors[i3 + 1] = 0.9 * brightness;
                    colors[i3 + 2] = 1.0 * brightness;
                } else if (temp < 0.7) {
                    // White-yellow stars (like our sun)
                    colors[i3] = 1.0 * brightness;
                    colors[i3 + 1] = 0.95 * brightness;
                    colors[i3 + 2] = 0.8 * brightness;
                } else if (temp < 0.9) {
                    // Orange stars
                    colors[i3] = 1.0 * brightness;
                    colors[i3 + 1] = 0.7 * brightness;
                    colors[i3 + 2] = 0.4 * brightness;
                } else {
                    // Red giants
                    colors[i3] = 1.0 * brightness;
                    colors[i3 + 1] = 0.4 * brightness;
                    colors[i3 + 2] = 0.2 * brightness;
                }
                
                // Much smaller, more realistic star sizes
                sizes[i] = Math.random() * 0.8 + 0.2;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: false,
                blending: THREE.AdditiveBlending
            });
            
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            
            // Enhanced Milky Way with more realistic appearance
            const milkyWayGeometry = new THREE.BufferGeometry();
            const milkyWayCount = 8000;
            const milkyWayPositions = new Float32Array(milkyWayCount * 3);
            const milkyWayColors = new Float32Array(milkyWayCount * 3);
            
            for (let i = 0; i < milkyWayCount; i++) {
                const i3 = i * 3;
                
                // Create galaxy band across the sky
                const angle = (Math.random() - 0.5) * Math.PI * 0.6;
                const bandWidth = Math.random() * 40 + 20;
                const distance = Math.random() * 600 + 400;
                
                milkyWayPositions[i3] = Math.cos(angle) * distance + (Math.random() - 0.5) * bandWidth;
                milkyWayPositions[i3 + 1] = Math.sin(angle) * 50 + 80 + (Math.random() - 0.5) * bandWidth * 0.5;
                milkyWayPositions[i3 + 2] = (Math.random() - 0.5) * 1000;
                
                // Milky Way colors - predominantly blue-white with some variation
                const intensity = Math.random() * 0.6 + 0.4;
                milkyWayColors[i3] = 0.8 * intensity;
                milkyWayColors[i3 + 1] = 0.9 * intensity;
                milkyWayColors[i3 + 2] = 1.0 * intensity;
            }
            
            milkyWayGeometry.setAttribute('position', new THREE.BufferAttribute(milkyWayPositions, 3));
            milkyWayGeometry.setAttribute('color', new THREE.BufferAttribute(milkyWayColors, 3));
            
            const milkyWayMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: false,
                blending: THREE.AdditiveBlending
            });
            
            milkyWay = new THREE.Points(milkyWayGeometry, milkyWayMaterial);
            scene.add(milkyWay);
        }

        function createEnhancedRiver() {
            // Create more realistic water with higher tessellation for smoother waves
            const riverGeometry = new THREE.PlaneGeometry(40, 80, 160, 160);
            
            // Enhanced water material with realistic reflections and depth
            riverMaterial = new THREE.MeshStandardMaterial({
                color: 0x001133,
                transparent: true,
                opacity: 0.8,
                metalness: 0.9,
                roughness: 0.1,
                side: THREE.DoubleSide
            });
            
            // Create environment map for water reflections
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(128);
            const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
            scene.add(cubeCamera);
            riverMaterial.envMap = cubeRenderTarget.texture;

            // Create endless river segments
            for (let i = 0; i < 20; i++) {
                const riverMesh = new THREE.Mesh(riverGeometry.clone(), riverMaterial);
                riverMesh.rotation.x = -Math.PI / 2;
                riverMesh.position.z = -i * 80;
                riverMesh.position.y = -1;
                
                // Enhanced wave data
                const positions = riverMesh.geometry.attributes.position.array;
                riverMesh.userData.originalPositions = positions.slice();
                riverMesh.userData.time = Math.random() * Math.PI * 2;
                riverMesh.userData.waveSpeed = 0.8 + Math.random() * 0.4;
                
                riverSegments.push(riverMesh);
                scene.add(riverMesh);
            }
            
            // River depth layers for better depth perception
            const depthGeometry = new THREE.PlaneGeometry(40, 80);
            const depthMaterial = new THREE.MeshStandardMaterial({
                color: 0x000022,
                transparent: true,
                opacity: 0.95,
                metalness: 0.2,
                roughness: 0.8
            });
            
            for (let i = 0; i < 20; i++) {
                const depthMesh = new THREE.Mesh(depthGeometry, depthMaterial);
                depthMesh.rotation.x = -Math.PI / 2;
                depthMesh.position.z = -i * 80;
                depthMesh.position.y = -3;
                scene.add(depthMesh);
            }
        }

        function createDetailedBoat() {
            const boatGroup = new THREE.Group();
            
            // More detailed hull with better curves
            const hullGeometry = new THREE.CylinderGeometry(0.8, 1.2, 5, 16);
            const hullMaterial = new THREE.MeshPhongMaterial({
                color: 0x8B4513,
                shininess: 40,
                specular: 0x555555
            });
            
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.position.y = 0.3;
            hull.rotation.x = Math.PI / 2;
            boatGroup.add(hull);
            
            // Enhanced wooden details
            for (let i = -2; i <= 2; i += 0.3) {
                const plankGeometry = new THREE.BoxGeometry(0.05, 0.08, 4.5);
                const plankMaterial = new THREE.MeshPhongMaterial({
                    color: 0x654321,
                    shininess: 25
                });
                const plank = new THREE.Mesh(plankGeometry, plankMaterial);
                plank.position.set(i, 0.4, 0);
                boatGroup.add(plank);
            }
            
            // Improved seats with cushions
            const seatGeometry = new THREE.BoxGeometry(2, 0.2, 0.5);
            const seatMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B4513,
                shininess: 30
            });
            
            const cushionGeometry = new THREE.BoxGeometry(1.8, 0.1, 0.4);
            const cushionMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B0000,
                shininess: 10
            });
            
            // Front seat with cushion
            const frontSeat = new THREE.Mesh(seatGeometry, seatMaterial);
            frontSeat.position.set(0, 0.6, 1.5);
            boatGroup.add(frontSeat);
            
            const frontCushion = new THREE.Mesh(cushionGeometry, cushionMaterial);
            frontCushion.position.set(0, 0.75, 1.5);
            boatGroup.add(frontCushion);
            
            // Back seat with cushion
            const backSeat = new THREE.Mesh(seatGeometry, seatMaterial);
            backSeat.position.set(0, 0.6, -1.5);
            boatGroup.add(backSeat);
            
            const backCushion = new THREE.Mesh(cushionGeometry, cushionMaterial);
            backCushion.position.set(0, 0.75, -1.5);
            boatGroup.add(backCushion);
            
            // Enhanced oars with better detail
            const oarGeometry = new THREE.CylinderGeometry(0.04, 0.04, 3);
            const oarMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B4513,
                shininess: 20
            });
            
            const leftOar = new THREE.Mesh(oarGeometry, oarMaterial);
            leftOar.position.set(-1.5, 0.8, 0);
            leftOar.rotation.z = Math.PI / 2;
            boatGroup.add(leftOar);
            
            const rightOar = new THREE.Mesh(oarGeometry, oarMaterial);
            rightOar.position.set(1.5, 0.8, 0);
            rightOar.rotation.z = Math.PI / 2;
            boatGroup.add(rightOar);
            
            // Oar blades with better shape
            const bladeGeometry = new THREE.BoxGeometry(0.4, 0.08, 1);
            const leftBlade = new THREE.Mesh(bladeGeometry, oarMaterial);
            leftBlade.position.set(-3, 0.8, 0);
            boatGroup.add(leftBlade);
            
            const rightBlade = new THREE.Mesh(bladeGeometry, oarMaterial);
            rightBlade.position.set(3, 0.8, 0);
            boatGroup.add(rightBlade);
            
            // Add lantern for atmospheric lighting
            const lanternPole = new THREE.CylinderGeometry(0.02, 0.02, 1.5);
            const lanternPoleMesh = new THREE.Mesh(lanternPole, new THREE.MeshPhongMaterial({ color: 0x444444 }));
            lanternPoleMesh.position.set(0, 1.5, 2);
            boatGroup.add(lanternPoleMesh);
            
            const lanternGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const lanternMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFAA00,
                emissive: 0x552200,
                transparent: true,
                opacity: 0.8
            });
            const lantern = new THREE.Mesh(lanternGeometry, lanternMaterial);
            lantern.position.set(0, 2.2, 2);
            boatGroup.add(lantern);
            
            // Add lantern light
            const lanternLight = new THREE.PointLight(0xFFAA00, 1, 15);
            lanternLight.position.set(0, 2.2, 2);
            boatGroup.add(lanternLight);
            
            boat = boatGroup;
            scene.add(boat);
        }

        function createRichEnvironment() {
            // Enhanced forest with more variety and detail
            // Enhanced tree types with more natural shapes and variations
            const treeTypes = [
                {
                    createGeometry: () => {
                        const treeGroup = new THREE.Group();
                        // Pine tree with multiple layers
                        const layers = 5;
                        for (let i = 0; i < layers; i++) {
                            const scale = 1 - (i / layers) * 0.6;
                            const cone = new THREE.ConeGeometry(1.2 * scale, 2, 8);
                            const material = new THREE.MeshPhongMaterial({
                                color: new THREE.Color(0x1a472a).offsetHSL(0, 0, Math.random() * 0.2 - 0.1),
                                shininess: 0,
                                flatShading: true
                            });
                            const layer = new THREE.Mesh(cone, material);
                            layer.position.y = i * 1.2;
                            treeGroup.position.y = 3;
                            treeGroup.add(layer);
                        }
                        return treeGroup;
                    },
                    height: 8,
                    type: 'pine'
                },
                {
                    createGeometry: () => {
                        const treeGroup = new THREE.Group();
                        // Oak tree with irregular canopy
                        const segments = 6;
                        for (let i = 0; i < segments; i++) {
                            const sphere = new THREE.SphereGeometry(
                                1.5 + Math.random() * 0.5,
                                6,
                                6
                            );
                            const material = new THREE.MeshPhongMaterial({
                                color: new THREE.Color(0x2d5a27).offsetHSL(0, 0, Math.random() * 0.2 - 0.1),
                                shininess: 0,
                                flatShading: true
                            });
                            const segment = new THREE.Mesh(sphere, material);
                            segment.position.set(
                                (Math.random() - 0.5) * 2,
                                i * 0.8,
                                (Math.random() - 0.5) * 2
                            );
                            segment.scale.set(
                                0.8 + Math.random() * 0.4,
                                0.8 + Math.random() * 0.4,
                                0.8 + Math.random() * 0.4
                            );
                            treeGroup.add(segment);
                        }
                        return treeGroup;
                    },
                    height: 6,
                    type: 'oak'
                },
                {
                    createGeometry: () => {
                        const treeGroup = new THREE.Group();
                        // Willow tree with drooping branches
                        const branchCount = 8;
                        const curve = new THREE.CatmullRomCurve3([
                            new THREE.Vector3(0, 6, 0),
                            new THREE.Vector3(2, 4, 0),
                            new THREE.Vector3(3, 2, 0),
                            new THREE.Vector3(2.5, 0, 0)
                        ]);
                        
                        for (let i = 0; i < branchCount; i++) {
                            const branchGeometry = new THREE.TubeGeometry(
                                curve,
                                20,
                                0.1,
                                8,
                                false
                            );
                            const material = new THREE.MeshPhongMaterial({
                                color: new THREE.Color(0x3a5f0b).offsetHSL(0, 0, Math.random() * 0.2 - 0.1),
                                shininess: 0
                            });
                            const branch = new THREE.Mesh(branchGeometry, material);
                            branch.rotation.y = (Math.PI * 2 * i) / branchCount;
                            treeGroup.add(branch);
                        }
                        return treeGroup;
                    },
                    height: 7,
                    type: 'willow'
                },
                {
                    createGeometry: () => {
                        const treeGroup = new THREE.Group();
                        // Bamboo-like tree with segments
                        const height = 8;
                        const segments = 6;
                        for (let i = 0; i < segments; i++) {
                            const segment = new THREE.CylinderGeometry(
                                0.2 - (i * 0.02),
                                0.2 - (i * 0.02),
                                height / segments,
                                8
                            );
                            const material = new THREE.MeshPhongMaterial({
                                color: new THREE.Color(0x234010).offsetHSL(0, 0, Math.random() * 0.1),
                                shininess: 20
                            });
                            const mesh = new THREE.Mesh(segment, material);
                            mesh.position.y = (i * height) / segments;
                            treeGroup.add(mesh);
                        }
                        return treeGroup;
                    },
                    height: 8,
                    type: 'bamboo'
                }
            ];
            
            // Create dense, natural forest with varied vegetation
            for (let z = 50; z > -800; z -= 2) {
                for (let side = 0; side < 2; side++) {
                    const riverSide = side === 0 ? -1 : 1;
                    
                    // Multiple forest layers with natural distribution
                    const layerCount = Math.floor(6 + Math.random() * 3);
                    for (let layer = 0; layer < layerCount; layer++) {
                        // Perlin noise for natural distribution
                        const noise = Math.sin(z * 0.05) * Math.cos(layer * 0.8) * 0.5 + 0.5;
                        if (Math.random() > noise * 0.8) continue;
                        
                        const treeType = treeTypes[Math.floor(Math.random() * treeTypes.length)];
                        const tree = treeType.createGeometry();
                        
                        const baseDistance = 15 + layer * 5;
                        const variation = (Math.random() - 0.5) * 8;
                        
                        tree.position.set(
                            riverSide * (baseDistance + variation),
                            0,
                            z + (Math.random() - 0.5) * 4
                        );
                        
                        tree.rotation.y = Math.random() * Math.PI * 2;
                        const scale = 0.6 + Math.random() * 0.8;
                        tree.scale.set(scale, scale * (0.9 + Math.random() * 0.2), scale);
                        
                        // Add some random rotation for more natural look
                        tree.rotation.x = (Math.random() - 0.5) * 0.1;
                        tree.rotation.z = (Math.random() - 0.5) * 0.1;
                        
                        scene.add(tree);
                        
                        // Enhanced natural ground vegetation
                        if (Math.random() > 0.7) {
                            const bushCount = Math.floor(Math.random() * 3) + 1;
                            for (let b = 0; b < bushCount; b++) {
                                const bushGeometry = new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 6, 6);
                                const bushMaterial = new THREE.MeshPhongMaterial({
                                    color: new THREE.Color(0x1a4719).offsetHSL(0, 0, Math.random() * 0.2 - 0.1),
                                    shininess: 0,
                                    flatShading: true
                                });
                                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                                bush.position.set(
                                    tree.position.x + (Math.random() - 0.5) * 2,
                                    Math.random() * 0.5,
                                    tree.position.z + (Math.random() - 0.5) * 2
                                );
                                bush.scale.y = 0.7;
                                scene.add(bush);
                            }
                        }
                        
                        // Enhanced trunk with natural texture
                        const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.25, treeType.height * 0.8, 8);
                        const trunkMaterial = new THREE.MeshPhongMaterial({ 
                            color: new THREE.Color(0x4A2C2A).offsetHSL(0, 0, Math.random() * 0.1 - 0.05),
                            shininess: 5,
                            bumpScale: 0.5,
                            flatShading: true
                        });
                        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                        trunk.position.set(tree.position.x, treeType.height * 0.4, tree.position.z);
                        trunk.rotation.set(
                            tree.rotation.x * 0.5,
                            tree.rotation.y,
                            tree.rotation.z * 0.5
                        );
                        scene.add(trunk);
                    }
                }
            }
            
            // Create natural rock formations and terrain features
            const createRockFormation = (basePosition, size) => {
                const formation = new THREE.Group();
                const rockCount = Math.floor(3 + Math.random() * 5);
                
                for (let i = 0; i < rockCount; i++) {
                    // Create irregular rock shapes
                    const geometry = new THREE.IcosahedronGeometry(size * (0.3 + Math.random() * 0.7), 1);
                    
                    // Distort vertices for more natural look
                    const vertices = geometry.attributes.position.array;
                    for (let j = 0; j < vertices.length; j += 3) {
                        vertices[j] *= 1 + (Math.random() - 0.5) * 0.3;
                        vertices[j + 1] *= 1 + (Math.random() - 0.5) * 0.3;
                        vertices[j + 2] *= 1 + (Math.random() - 0.5) * 0.3;
                    }
                    geometry.computeVertexNormals();
                    
                    // Natural rock material with slight variation
                    const rockMaterial = new THREE.MeshPhongMaterial({
                        color: new THREE.Color(0x505050).offsetHSL(0, 0, Math.random() * 0.1 - 0.05),
                        shininess: 2,
                        flatShading: true
                    });
                    
                    const rock = new THREE.Mesh(geometry, rockMaterial);
                    rock.position.set(
                        (Math.random() - 0.5) * size * 2,
                        (Math.random() * 0.5) * size,
                        (Math.random() - 0.5) * size * 2
                    );
                    rock.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    formation.add(rock);
                }
                
                formation.position.copy(basePosition);
                return formation;
            };
            
            // Add varied rock formations along the river
            for (let z = 0; z > -800; z -= 20) {
                for (let side = 0; side < 2; side++) {
                    const riverSide = side === 0 ? -1 : 1;
                    
                    // Create larger rock formations less frequently
                    if (Math.random() > 0.7) {
                        const basePosition = new THREE.Vector3(
                            riverSide * (18 + Math.random() * 15),
                            -1,
                            z + Math.random() * 10
                        );
                        const formation = createRockFormation(basePosition, 2 + Math.random() * 2);
                        scene.add(formation);
                        
                        // Add smaller rocks around the formation
                        const smallRockCount = Math.floor(Math.random() * 5) + 3;
                        for (let i = 0; i < smallRockCount; i++) {
                            const smallRockPos = new THREE.Vector3(
                                basePosition.x + (Math.random() - 0.5) * 6,
                                basePosition.y,
                                basePosition.z + (Math.random() - 0.5) * 6
                            );
                            const smallFormation = createRockFormation(smallRockPos, 0.5 + Math.random());
                            scene.add(smallFormation);
                        }
                    }
                    
                    // Occasionally add single rocks
                    if (Math.random() > 0.8) {
                        const rockPos = new THREE.Vector3(
                            riverSide * (15 + Math.random() * 20),
                            -0.5,
                            z + Math.random() * 20
                        );
                        const rock = createRockFormation(rockPos, 0.8 + Math.random());
                        scene.add(rock);
                    }
                }
            }
            
            // Add mystical floating particles
            const particleCount = 500;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 80;
                positions[i3 + 1] = Math.random() * 15 + 1;
                positions[i3 + 2] = (Math.random() - 0.5) * 300;
                
                velocities[i3] = (Math.random() - 0.5) * 0.01;
                velocities[i3 + 1] = Math.random() * 0.005 + 0.005;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
                
                // Mystical particle colors
                colors[i3] = 0.5 + Math.random() * 0.5;
                colors[i3 + 1] = 0.8 + Math.random() * 0.2;
                colors[i3 + 2] = 1.0;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            window.particles = particles;
        }

        function createMistEffects() {
            // Create volumetric mist particles
            const mistParticleCount = 2000;
            const mistGeometry = new THREE.BufferGeometry();
            const mistPositions = new Float32Array(mistParticleCount * 3);
            const mistSizes = new Float32Array(mistParticleCount);
            const mistOpacities = new Float32Array(mistParticleCount);
            
            for (let i = 0; i < mistParticleCount; i++) {
                const i3 = i * 3;
                // Distribute mist particles in a natural, flowing pattern
                mistPositions[i3] = (Math.random() - 0.5) * 60;
                mistPositions[i3 + 1] = Math.random() * 3;
                mistPositions[i3 + 2] = -Math.random() * 300;
                
                // Varied sizes for more natural look
                mistSizes[i] = Math.random() * 4 + 2;
                mistOpacities[i] = Math.random() * 0.3 + 0.1;
            }
            
            mistGeometry.setAttribute('position', new THREE.BufferAttribute(mistPositions, 3));
            mistGeometry.setAttribute('size', new THREE.BufferAttribute(mistSizes, 1));
            mistGeometry.setAttribute('opacity', new THREE.BufferAttribute(mistOpacities, 1));
            
            // Custom shader material for smoky mist effect
            const mistMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    fogColor: { value: new THREE.Color(0x88AACC) }
                },
                vertexShader: `
                    attribute float size;
                    attribute float opacity;
                    varying float vOpacity;
                    uniform float time;
                    
                    void main() {
                        vOpacity = opacity;
                        vec3 pos = position;
                        pos.y += sin(time * 0.3 + position.x * 0.05) * 0.2;
                        pos.x += sin(time * 0.2 + position.z * 0.05) * 0.2;
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vOpacity;
                    uniform vec3 fogColor;
                    
                    void main() {
                        float r = length(gl_PointCoord - vec2(0.5));
                        if (r > 0.5) discard;
                        float opacity = smoothstep(0.5, 0.0, r) * vOpacity;
                        gl_FragColor = vec4(fogColor, opacity);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            const mistParticles = new THREE.Points(mistGeometry, mistMaterial);
            mist.push(mistParticles);
            scene.add(mistParticles);
        }

        function createFireflies() {
            // Create more natural firefly swarms
            const swarmCount = 5; // Number of firefly swarms
            const firefliesPerSwarm = 40;
            
            for (let swarm = 0; swarm < swarmCount; swarm++) {
                // Create swarm center points
                const swarmCenter = new THREE.Vector3(
                    (Math.random() - 0.5) * 80,
                    Math.random() * 6 + 3,
                    -Math.random() * 300
                );
                
                for (let i = 0; i < firefliesPerSwarm; i++) {
                    const fireflyGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const fireflyMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color(0xFFEB94),
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const firefly = new THREE.Mesh(fireflyGeometry, fireflyMaterial);
                    
                    // Position fireflies relative to swarm center
                    const radius = Math.random() * 5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    firefly.position.set(
                        swarmCenter.x + radius * Math.sin(phi) * Math.cos(theta),
                        swarmCenter.y + radius * Math.cos(phi),
                        swarmCenter.z + radius * Math.sin(phi) * Math.sin(theta)
                    );
                    
                    // Enhanced firefly glow
                    const glowGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const glowMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            glowColor: { value: new THREE.Color(0xFFEB94) },
                            intensity: { value: 1.0 }
                        },
                        vertexShader: `
                            varying vec3 vNormal;
                            void main() {
                                vNormal = normalize(normalMatrix * normal);
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 glowColor;
                            uniform float intensity;
                            varying vec3 vNormal;
                            void main() {
                                float opacity = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                                gl_FragColor = vec4(glowColor, opacity * intensity * 0.5);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide
                    });
                    
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    firefly.add(glow);
                    
                    // Subtle point light
                    const fireflyLight = new THREE.PointLight(0xFFEB94, 0.4, 3);
                    firefly.add(fireflyLight);
                    
                    firefly.userData = {
                        originalPosition: firefly.position.clone(),
                        swarmCenter: swarmCenter.clone(),
                        time: Math.random() * Math.PI * 2,
                        speed: 0.3 + Math.random() * 0.4,
                        radius: radius,
                        swarmOffset: new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        )
                    };
                    
                    fireflies.push(firefly);
                    scene.add(firefly);
                }
            }
        }

        function setupEnhancedLighting() {
            // Enhanced ambient lighting
            const ambientLight = new THREE.AmbientLight(0x404080, 0.6);
            scene.add(ambientLight);

            // Moonlight with better shadows
            const moonLight = new THREE.DirectionalLight(0x9999FF, 1.2);
            moonLight.position.set(30, 50, 20);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            moonLight.shadow.camera.near = 0.5;
            moonLight.shadow.camera.far = 500;
            scene.add(moonLight);

            // Add secondary moon glow
            const secondaryMoonLight = new THREE.DirectionalLight(0x6666FF, 0.3);
            secondaryMoonLight.position.set(-20, 30, -20);
            scene.add(secondaryMoonLight);

            // Enhanced river glow
            const riverLight = new THREE.PointLight(0x0099FF, 1.5, 40);
            riverLight.position.set(0, 2, 0);
            scene.add(riverLight);
            
            // Add hemisphere light for better ambient lighting
            const hemisphereLight = new THREE.HemisphereLight(0x0099FF, 0x002244, 0.8);
            scene.add(hemisphereLight);
            
            // Add ground reflection light
            const groundLight = new THREE.PointLight(0x001133, 0.4, 50);
            groundLight.position.set(0, -2, 0);
            scene.add(groundLight);
        }

        function setupControls() {
            // Enhanced keyboard controls
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'Space') {
                    e.preventDefault();
                    dashMode = true;
                }
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                    glideMode = true;
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === 'Space') {
                    dashMode = false;
                }
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                    glideMode = false;
                }
            });

            // Enhanced mouse controls
            document.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            });


            // Pointer lock for better mouse control
            document.addEventListener('click', () => {
                document.body.requestPointerLock();
            });

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === document.body) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            function onMouseMove(e) {
                boatRotation.y -= e.movementX * 0.002;
                // Limit vertical looking
                boatRotation.x = Math.max(-0.5, Math.min(0.5, boatRotation.x - e.movementY * 0.002));
            }
        }

        function updateBoat() {
            const time = clock.getElapsedTime();
            rockingTime += 0.016;
            
            // Handle movement with smoother acceleration
            let targetSpeed = dashMode ? boatSpeed * 3 : boatSpeed;
            if (glideMode) targetSpeed *= 0.3;
            
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            
            forward.applyQuaternion(boat.quaternion);
            right.applyQuaternion(boat.quaternion);
            
            if (keys['KeyW'] || keys['ArrowUp']) {
                boatPosition.add(forward.multiplyScalar(targetSpeed));
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                boatPosition.add(forward.multiplyScalar(-targetSpeed * 0.5));
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                boatPosition.add(right.multiplyScalar(-targetSpeed * 0.6));
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                boatPosition.add(right.multiplyScalar(targetSpeed * 0.6));
            }
            
            // More realistic boat physics with water interaction
            const rockingIntensity = glideMode ? 0.2 : 0.6;
            const waterHeight = Math.sin(boatPosition.x * 0.3 + time) * 0.05 + 
                              Math.sin(boatPosition.z * 0.2 + time * 0.7) * 0.03;
            
            boat.position.copy(boatPosition);
            boat.position.y = waterHeight + Math.sin(rockingTime * 0.8) * 0.08 * rockingIntensity;
            
            // Realistic boat rocking with momentum
            boat.rotation.x = Math.sin(rockingTime * 0.6) * 0.04 * rockingIntensity + 
                            Math.sin(boatPosition.z * 0.1 + time) * 0.02;
            boat.rotation.z = Math.sin(rockingTime * 0.4) * 0.03 * rockingIntensity + 
                            Math.sin(boatPosition.x * 0.1 + time) * 0.02;
            boat.rotation.y = boatRotation.y;
            
            // Update river segments for endless effect
            riverSegments.forEach((segment, index) => {
                if (segment.position.z > boatPosition.z + 30) {
                    segment.position.z -= 900;
                    // Add randomization to river segments for variety
                    segment.rotation.x = -Math.PI / 2 + (Math.random() - 0.5) * 0.05;
                }
            });

            // Update mist position for endless effect
            mist.forEach(mistPlane => {
                if (mistPlane.position.z > boatPosition.z + 30) {
                    mistPlane.position.z -= 300;
                    mistPlane.position.x = (Math.random() - 0.5) * 30;
                    mistPlane.position.y = 0.5 + Math.random() * 2;
                    mistPlane.rotation.y = Math.random() * Math.PI * 2;
                }
            });

            // Update fireflies
            fireflies.forEach(firefly => {
                const data = firefly.userData;
                data.time += data.speed * 0.016;
                
                // Organic firefly movement
                firefly.position.x = data.originalPosition.x + Math.sin(data.time * 0.5) * 2;
                firefly.position.y = data.originalPosition.y + Math.cos(data.time * 0.7) * 1;
                firefly.position.z = data.originalPosition.z + Math.sin(data.time * 0.3) * 2;
                
                // Pulsing light intensity
                const intensity = 0.3 + Math.sin(data.time * 2) * 0.2;
                firefly.children[0].intensity = intensity;
                
                // Reset firefly position if too far from boat
                if (firefly.position.z > boatPosition.z + 30) {
                    data.originalPosition.z -= 200;
                    firefly.position.copy(data.originalPosition);
                }
            });
        }

        function updateCamera() {
            const idealPosition = new THREE.Vector3();
            const idealLookAt = new THREE.Vector3();
            
            // Camera follows boat with dynamic offset
            const offset = cameraOffset.clone();
            if (glideMode) {
                offset.y += 1;
                offset.z += 2;
            }
            offset.applyQuaternion(boat.quaternion);
            idealPosition.copy(boatPosition).add(offset);
            idealLookAt.copy(boatPosition);
            
            // Enhanced mouse look with smoother response
            const mouseInfluence = glideMode ? 0.4 : 0.3;
            idealPosition.x += mouseX * mouseInfluence;
            idealPosition.y += mouseY * mouseInfluence + 1;
            idealLookAt.x += mouseX * mouseInfluence * 0.5;
            idealLookAt.y += mouseY * mouseInfluence * 0.5;
            
            // Smooth camera movement with dynamic interpolation
            const lerpFactor = glideMode ? 0.05 : 0.1;
            camera.position.lerp(idealPosition, lerpFactor);
            camera.lookAt(idealLookAt);

            // Update fog density based on height
            scene.fog.density = 0.008 + Math.max(0, (camera.position.y - 5) * 0.001);
        }

        function updateEffects() {
            const time = clock.getElapsedTime();
            
            // Enhanced water wave animation
            riverSegments.forEach((segment, index) => {
                const positions = segment.geometry.attributes.position.array;
                const originalPositions = segment.userData.originalPositions;
                segment.userData.time += 0.02;
                
                for (let i = 0; i < positions.length; i += 3) {
                    const x = originalPositions[i];
                    const z = originalPositions[i + 2];
                    
                    // Multiple wave frequencies for more realistic water
                    const wave1 = Math.sin(x * 0.3 + segment.userData.time) * 0.05;
                    const wave2 = Math.sin(z * 0.2 + segment.userData.time * 0.7) * 0.03;
                    const wave3 = Math.sin((x + z) * 0.1 + segment.userData.time * 1.2) * 0.02;
                    const wave4 = Math.sin((x - z) * 0.15 + segment.userData.time * 0.9) * 0.015;
                    
                    positions[i + 1] = wave1 + wave2 + wave3 + wave4;
                }
                
                segment.geometry.attributes.position.needsUpdate = true;
                segment.geometry.computeVertexNormals();
            });
            
            // Dynamic river color based on depth and time
            const hue = 0.55 + Math.sin(time * 0.3) * 0.1;
            const lightness = 0.15 + Math.sin(time * 0.5) * 0.05;
            riverMaterial.color.setHSL(hue, 0.8, lightness);
            riverMaterial.specular.setHSL(hue + 0.1, 0.9, 0.6);
            
            // Enhanced star twinkling with depth variation
            const starPositions = stars.geometry.attributes.position.array;
            const starColors = stars.geometry.attributes.color.array;
            const starSizes = stars.geometry.attributes.size.array;
            
            for (let i = 0; i < starPositions.length; i += 3) {
                const distance = Math.sqrt(
                    Math.pow(starPositions[i], 2) + 
                    Math.pow(starPositions[i + 1], 2) + 
                    Math.pow(starPositions[i + 2], 2)
                );
                
                // Varied twinkling speeds based on star position
                const twinkleSpeed = (1 + (i % 5)) * 0.5;
                const twinkle = Math.sin(time * twinkleSpeed + distance * 0.01) * 0.3 + 0.7;
                
                const colorIndex = i;
                starColors[colorIndex] *= twinkle;
                starColors[colorIndex + 1] *= twinkle;
                starColors[colorIndex + 2] *= twinkle;
                
                // Dynamic star size based on distance and time
                const sizeIndex = i / 3;
                starSizes[sizeIndex] = (0.2 + Math.sin(time + distance * 0.01) * 0.1) * 
                                     (1 - Math.min(1, distance / 1000));
            }
            
            stars.geometry.attributes.color.needsUpdate = true;
            stars.geometry.attributes.size.needsUpdate = true;
            
            // Update Milky Way rotation
            milkyWay.rotation.x = Math.sin(time * 0.05) * 0.1;
            milkyWay.rotation.y = time * 0.02;
            
            // Animate atmospheric particles
            if (window.particles) {
                const particlePositions = window.particles.geometry.attributes.position.array;
                const particleVelocities = window.particles.geometry.attributes.velocity.array;
                
                for (let i = 0; i < particlePositions.length; i += 3) {
                    // Update particle positions with wind effect
                    particlePositions[i] += particleVelocities[i] + Math.sin(time + i * 0.1) * 0.002;
                    particlePositions[i + 1] += particleVelocities[i + 1] + Math.sin(time + i) * 0.001;
                    particlePositions[i + 2] += particleVelocities[i + 2];
                    
                    // Reset particles with smooth transitions
                    if (particlePositions[i] > 40) particlePositions[i] = -40;
                    if (particlePositions[i] < -40) particlePositions[i] = 40;
                    if (particlePositions[i + 1] > 20) {
                        particlePositions[i + 1] = 1;
                        particleVelocities[i + 1] = Math.random() * 0.005 + 0.005;
                    }
                    if (particlePositions[i + 2] > boatPosition.z + 100) {
                        particlePositions[i + 2] = boatPosition.z - 100;
                    }
                }
                
                window.particles.geometry.attributes.position.needsUpdate = true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            
            if (!isLoading) {
                updateBoat();
                updateCamera();
                updateEffects();
                
                // Update mist shader time
                mist.forEach(mistParticle => {
                    if (mistParticle.material.uniforms) {
                        mistParticle.material.uniforms.time.value = time;
                    }
                });
                
                // Rotate entire star field slowly
                if (stars) {
                    stars.rotation.y += 0.0001;
                }

                // Update environment map for water reflection
                if (cubeCamera) {
                    cubeCamera.update(renderer, scene);
                }
            }
            
            // Update loading progress
            if (isLoading) {
                const progress = (loadedItems / totalItems) * 100;
                document.getElementById('loading').textContent = `âœ¨ Loading your dreamlike journey... ${Math.floor(progress)}%`;
            }
            
            renderer.render(scene, camera);
        }

        // Enhanced window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });

        init();
    </script>
</body>
</html>
